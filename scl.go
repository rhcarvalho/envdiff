package main

import (
	"fmt"
	"io"
	"os/exec"
	"strings"
)

// writeInstalledCollectionsEnvDiff writes to w the environment difference
// resulting of enabling all collections installed in image. If asDockerfile is
// true, a format suitable for including the output in a Dockerfile is used,
// otherwise a format suitable for shell scripts is used.
func writeInstalledCollectionsEnvDiff(w io.Writer, image string, asDockerfile bool) error {
	// Validate image name.
	if image == "" {
		return fmt.Errorf("missing image name")
	}
	// Check for required binaries in the host system.
	if _, err := exec.LookPath("env"); err != nil {
		return fmt.Errorf("missing \"env\": %v", err)
	}
	if _, err := exec.LookPath("docker"); err != nil {
		return fmt.Errorf("missing \"docker\": %v", err)
	}
	env, collections, err := getInstalledCollectionsEnvDiff(image)
	if err != nil {
		return err
	}
	if asDockerfile {
		writeAsDockerfile(w, env, collections)
	} else {
		writeAsShell(w, env, collections)
	}
	return nil
}

// getInstalledCollectionsEnvDiff returns the environment difference resulting
// of enabling all collections installed in image, and the list of installed
// collections.
func getInstalledCollectionsEnvDiff(image string) (Env, []string, error) {
	collections, err := getInstalledCollections(image)
	if err != nil {
		return nil, nil, fmt.Errorf("getInstalledCollections: %v", err)
	}
	old, err := getCleanEnv(image)
	if err != nil {
		return nil, nil, fmt.Errorf("getCleanEnv: %v", err)
	}
	new, err := getEnvWithCollections(image, collections...)
	if err != nil {
		return nil, nil, fmt.Errorf("getEnvWithCollections: %v", err)
	}
	diff := Diff(old, new)
	filteredDiff := diff[:0]
	for _, v := range diff {
		// Ignore irrelevant variables.
		if v.Name == "HOSTNAME" || v.Name == "SHLVL" {
			continue
		}
		filteredDiff = append(filteredDiff, v)
	}
	return filteredDiff, collections, nil
}

// getInstalledCollections returns a list of collections installed in the image.
func getInstalledCollections(image string) ([]string, error) {
	out, err := dockerRunCleanEnvCombinedOutput(image, "/usr/bin/scl", "--list")
	if err != nil {
		return nil, err
	}
	return strings.Split(strings.TrimSpace(string(out)), "\n"), nil
}

// getCleanEnv returns the environment of a fresh Bash session from a temporary
// container running the image.
func getCleanEnv(image string) (Env, error) {
	out, err := dockerRunCleanEnvCombinedOutput(image, "/bin/bash", "-c", "env")
	if err != nil {
		return nil, err
	}
	return Parse(string(out)), nil
}

// getEnvWithCollections returns the environment of a fresh Bash session from a
// temporary container running the image with the given collections enabled.
func getEnvWithCollections(image string, collections ...string) (Env, error) {
	args := append(append([]string{"enable"}, collections...), "env")
	out, err := dockerRunCleanEnvCombinedOutput(image, "/usr/bin/scl", args...)
	if err != nil {
		return nil, err
	}
	return Parse(string(out)), nil
}

// dockerRunCleanEnvCombinedOutput returns the combined stdout and stderr of a
// temporary container based on image with the given entrypoint and args, with
// all ennvironment variables set in the image being unset prior to starting
// the container.
func dockerRunCleanEnvCombinedOutput(image, entrypoint string, args ...string) ([]byte, error) {
	env, err := imageEnv(image)
	if err != nil {
		return nil, err
	}
	out, err := dockerRunUnsetEnv(env, image, entrypoint, args...).CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("%s: %v", out, err)
	}
	return out, nil
}

// imageEnv returns the environment declared in a Docker image.
func imageEnv(image string) (Env, error) {
	out, err := exec.Command("docker", "inspect", "--type=image",
		`--format='{{range .Config.Env}}{{printf "%v\x00" .}}{{end}}'`,
		image).Output()
	if err != nil {
		return nil, err
	}
	return Parse(string(out)), nil
}

// dockerRunUnsetEnv returns a command that runs a temporary container based on
// the given image, with the given entrypoint and args, with all environment
// variables from env unset.
func dockerRunUnsetEnv(env Env, image, entrypoint string, args ...string) *exec.Cmd {
	var s []string
	for _, e := range env {
		s = append(s, "-u", e.Name)
	}
	s = append(s, "docker", "run", "--rm")
	for _, e := range env {
		s = append(s, "-e", e.Name)
	}
	// Reset PATH to Docker defaults.
	s = append(s, "-e", "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin")
	s = append(s, "--entrypoint", entrypoint, image)
	s = append(s, args...)
	return exec.Command("env", s...)
}

// writeAsDockerfile writes to w a Dockerfile ENV instruction setting env. If
// collections is non-nil, it should contain a list of collections associated
// with env.
func writeAsDockerfile(w io.Writer, env Env, collections []string) {
	if len(env) == 0 {
		// Nothing to be written.
		return
	}
	fmt.Fprintln(w, "# -- generated by https://github.com/rhcarvalho/envdiff, do not edit manually --")
	if collections != nil {
		fmt.Fprintln(w, "# The ENV instruction below is equivalent to:")
		fmt.Fprintln(w, "#   scl enable", strings.Join(collections, " "))
	}
	fmt.Fprintf(w, "ENV %s=%s", env[0].Name, strings.Join(env[0].Value, pathListSeparator))
	for _, v := range env[1:] {
		fmt.Fprintf(w, " \\\n    %s=%s", v.Name, strings.Join(v.Value, pathListSeparator))
	}
	fmt.Fprintln(w, "\n# ------------------------ end of generated instruction ------------------------")
}

// writeAsShell writes to w the environment variable in env, one per line. If
// collections is non-nil, it should contain a list of collections associated
// with env.
func writeAsShell(w io.Writer, env Env, collections []string) {
	if len(env) == 0 {
		// Nothing to be written.
		return
	}
	if collections != nil {
		fmt.Fprintln(w, "# scl enable", strings.Join(collections, " "))
	}
	fmt.Fprintln(w, env)
}
